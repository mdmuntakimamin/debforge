#!/usr/bin/env bash
set -Eeuo pipefail

ROOT="$HOME/debforge-aarch64"

VAR="$ROOT/var"
RUNTIME="$ROOT/runtime"
LOGS="$ROOT/logs"
OUT="$ROOT/output"

CACHE="$VAR/cache/debforge"
LIB="$VAR/lib/debforge"
STATE="$LIB/state"
RUN="$VAR/run/debforge"
LOCK="$VAR/lock"

LOG="$LOGS/clean.log"
PIDFILE="$RUN/clean.pid"
MAINLOCK="$LOCK/debforge.lock"

ts(){ date +"%Y-%m-%d %H:%M:%S"; }
log(){ printf "[%s][CLEAN] %s\n" "$(ts)" "$*" | tee -a "$LOG"; }
die(){ log "FATAL: $1"; exit 1; }

lock(){
  exec 8>"$MAINLOCK"
  flock -n 8 || die "another debforge process running"
}

pidfile(){
  mkdir -p "$RUN"
  echo $$ > "$PIDFILE"
}

cleanup_pid(){
  rm -f "$PIDFILE"
}

safe_rm(){
  local p="$1"
  [ -e "$p" ] && rm -rf "$p"
}

wipe_runtime(){
  log "cleaning runtime"
  safe_rm "$RUNTIME/stage"
  safe_rm "$RUNTIME/extract"
  safe_rm "$RUNTIME/rootfs"
}

wipe_cache(){
  log "cleaning cache"
  find "$CACHE" -type f -delete 2>/dev/null || true
}

wipe_logs(){
  log "cleaning logs"
  find "$LOGS" -type f ! -name "*.keep" -delete 2>/dev/null || true
}

wipe_state(){
  log "cleaning state"
  find "$STATE" -type f -delete 2>/dev/null || true
}

wipe_run(){
  log "cleaning run"
  find "$RUN" -type f ! -name "debforge.pid" -delete 2>/dev/null || true
}

wipe_locks(){
  log "cleaning locks"
  find "$LOCK" -type f -delete 2>/dev/null || true
}

wipe_output(){
  log "cleaning output"
  find "$OUT" -type f -name "*.deb" -delete 2>/dev/null || true
}

prune_old(){
  log "pruning old artifacts"
  find "$VAR" -type f -mtime +7 -delete 2>/dev/null || true
}

verify_clean(){
  log "verifying clean state"
  [ -d "$RUNTIME/rootfs" ] && die "rootfs not clean"
  [ -s "$STATE/build.state" ] && die "build state remains"
}

mode_all(){
  wipe_runtime
  wipe_cache
  wipe_logs
  wipe_state
  wipe_run
  wipe_locks
  wipe_output
}

mode_soft(){
  wipe_runtime
  wipe_cache
}

mode_logs(){
  wipe_logs
}

mode_state(){
  wipe_state
}

mode_failed(){
  log "cleaning failed builds"
  find "$OUT" -type f -name "*.failed" -delete 2>/dev/null || true
}

usage(){
  echo "debforge-clean [all|soft|logs|state|failed]"
  exit 1
}

trap 'cleanup_pid' EXIT
trap 'die "clean interrupted"' ERR

main(){
  lock
  pidfile
  mkdir -p "$CACHE" "$STATE" "$LOCK"

  case "${1:-all}" in
    all) mode_all ;;
    soft) mode_soft ;;
    logs) mode_logs ;;
    state) mode_state ;;
    failed) mode_failed ;;
    *) usage ;;
  esac

  prune_old
  verify_clean
  log "CLEAN COMPLETE"
}

main "$@"
